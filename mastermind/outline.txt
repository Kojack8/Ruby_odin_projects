WHEN EACH GAME BEGINS I HAVE 2 NAMES (IF 2ND PLAYER IS pc 2 NAME IS nil) AND A GAME MODE
  MODES: 1 - NPC CODEMAKER (first round)
         2 - NPC CODEBREAKER (first round)
         3 - PCs x 2


  GAME MODE 1 & 2 are the most similar because they merely alternate rounds
  But game mode 3 is also just game mode 1 repeated

  SO THE REAL GAME MODES ARE 
  1. HUMAN GUESS round
  2. PC GUESS ROUND

  12 guess per round
  At the start
  HUMAN GUESS
    enter the four keys one at a time
    COMPARE_THE_ANSWER 


    ----

COMPARING THE ANSWER.

  For reaching the beginning of this round the current CodeMAKER gets a point (but that \
  might happen in the parent function tbd)
  3 CHECKS IN A ROW
    1.) IS THE ANSWER ENTERED PERFECTLY?
      if so, the round is over. Switch the MAKER and BREAKER if multiple rounds selected
    2.) ARE THERE COLORED PEGS IN THE CORRECT POSITION?
      achieve this by comparing 0..3 key[i] == answer[i] 
        if so comparison.push("RED")
          *WHEN I DO THIS I WILL ALSO GENERATE AN ARRAY CONTAINING SUCCESSFULLY COMPARED COLORS
        else comparison.push(nil) 
    3.) GIVEN THE REMAINING, NON-CORRECT PEGS, ARE ANY OF THEM THE CORRECT COLOR IN THE WRONG
    POSITION?
      it's v important that it ignores already successful comparisons
        3-A.) Using the *succeed_colors array I should !delete the first occurance of \
              those colors from the key
        3-B.) Compare the new key 

  example.)
    @KEY - ['BLUE', 'BLUE', 'YELLOW', 'BLUE']
    @ANSWER - ['BLUE', 'GREEN', 'BLUE', 'WHITE']

    1. False
    2. @comparison = ['RED' , nil, nil, nil]
       succeed_colors = ['BLUE']
    3. succeed_colors.each do |x|
        key.slice!(key.index(x))
        answer.slice!(answer.index(x))
      answer.each do |x|
        if key.include?(x)
          key.slice!(key.index(x))
          comparison = comparison.map { |x| 
            if x == nil
              then x = 'W'
            else
            x = x
            end
            }

